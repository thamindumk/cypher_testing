// Create a single node
CREATE (n:Person {name: 'Alice'})

// Create a relationship between two nodes
MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})
CREATE (a)-[:KNOWS]->(b)

// Create multiple nodes
CREATE (a:Person {name: 'Charlie'}), (b:Person {name: 'Dave'})

// Create a node with multiple properties
CREATE (n:Person {name: 'Eve', age: 30, occupation: 'Engineer'})

// Match and return nodes
MATCH (n:Person) RETURN n

// Match with a condition
MATCH (n:Person {name: 'Alice'}) RETURN n

// Update a node's property
MATCH (n:Person {name: 'Alice'}) SET n.age = 25

// Delete a node
MATCH (n:Person {name: 'Charlie'}) DELETE n

// Create nodes and relationships in one statement
CREATE (a:Person {name: 'Frank'}), (b:Person {name: 'Grace'}), (a)-[:FRIENDS_WITH]->(b)

// Find all nodes connected to a specific node
MATCH (a:Person {name: 'Alice'})--(b) RETURN b

// Using WHERE clause for more complex matching
MATCH (n:Person) WHERE n.age > 25 RETURN n

// Create nodes with labels and properties
CREATE (n:Employee {name: 'Henry', position: 'Manager', salary: 60000})

// Add multiple relationships
MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Frank'}), (c:Person {name: 'Grace'})
CREATE (a)-[:KNOWS]->(b), (b)-[:KNOWS]->(c)

// Return nodes with specific properties
MATCH (n:Person) WHERE n.age IS NOT NULL RETURN n

// Using optional match
OPTIONAL MATCH (a:Person)-[:KNOWS]-(b:Person) RETURN a, b

// Remove a property
MATCH (n:Person {name: 'Eve'}) REMOVE n.occupation

// Aggregate functions
MATCH (n:Person) RETURN count(n)

// Sorting results
MATCH (n:Person) RETURN n ORDER BY n.name DESC

// Limit the number of results
MATCH (n:Person) RETURN n LIMIT 5

// Skip results
MATCH (n:Person) RETURN n SKIP 2

// Combining multiple operations
MATCH (n:Person {name: 'Alice'})
SET n.city = 'Wonderland'
RETURN n

// Merge to avoid duplicates
MERGE (n:Person {name: 'Isaac'}) ON CREATE SET n.created = timestamp() ON MATCH SET n.lastSeen = timestamp()

// Using WITH to chain queries
MATCH (n:Person {name: 'Alice'})
WITH n.name AS username
MATCH (m:Person {name: username})
RETURN m

// Complex nested queries
MATCH (a:Person)-[:KNOWS]->(b:Person)-[:KNOWS]->(c:Person)
WHERE a.name = 'Alice' AND c.age > 30
RETURN c

// Creating indexes
CREATE INDEX ON :Person(name)

// Using FOREACH for batch operations
MATCH (n:Person {name: 'Alice'})
FOREACH (x IN range(1, 5) | CREATE (n)-[:LIKES]->(:Item {name: 'Item ' + x}))

// Path queries
MATCH p=(a:Person {name: 'Alice'})-[:KNOWS*2..3]->(b:Person) RETURN p

// Shortest path query
MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Grace'})
RETURN shortestPath((a)-[*]-(b))

// Union of results
MATCH (n:Person) WHERE n.age < 30
RETURN n.name AS young
UNION
MATCH (n:Person) WHERE n.age >= 30
RETURN n.name AS not_young

// Using parameters
:param name => 'Alice'
MATCH (n:Person {name: $name}) RETURN n

// Subqueries
CALL {
  MATCH (n:Person {name: 'Alice'})
  RETURN n
}
RETURN count(*)

// Using APOC procedures (if installed)
CALL apoc.periodic.commit('CALL { MATCH (n:Person) RETURN n LIMIT 1000 } RETURN count(*)')

